function math.lerp(a, b, t)
	return a + (b - a) * t
end

function parseColor(v)
	local r,g,b,a = 255,255,255,255

	local hexRgb = v:match("^[%s]*%x%x%x%x%x%x")

	if hexRgb ~= nil then
		r,g,b = hexRgb:match("(%x%x)(%x%x)(%x%x)")
		a = v:sub(7)
		if a:len() ~= 2 then a = "FF" end
		r = tonumber(r, 16)
		g = tonumber(g, 16)
		b = tonumber(b, 16)
		a = tonumber(a, 16)
	else
		r,g,b,a = v:match("^[%s]*([^,]+)[%s]*,[%s]*([^,]+)[%s]*,[%s]*([^,]+)[%s]*[,]?[%s]*([^%s]*)")
		if a == "" then a = 255 end
		r = SKIN:ParseFormula(r)
		g = SKIN:ParseFormula(g)
		b = SKIN:ParseFormula(b)
		a = SKIN:ParseFormula(a)
	end

	return r,g,b,a
end

function buildSection(header, ...)
	local str = "[" .. header .. "]"
	local n = select("#", ...)
	n = n - (n % 2)
	if n == 0 then return str end

	str = str .. "\n"

	for i=1,n,2 do
		local k = select(i, ...)
		local v = select(i + 1, ...)
		str = str .. k .. "=" .. v .. "\n"
	end

	if curGroup ~= nil then
		str = str .. "Group=" .. curGroup["name"] .. "\n"
	end

	return str
end

function writeToFile(fileName, content)
	local file = io.open(SKIN:MakePathAbsolute(fileName), "w")
	file:write(content)
	file:close()
end



function getGradientString()
	local str = ""
	for i,v in ipairs(colors) do
		str = str .. "|" .. v["color"] .. ":" .. v["p"]
	end
	str = str:sub(2)
	return str
end

function Initialize()

	SKIN:Bang("!Draggable", 0)

	PAD = SKIN:ParseFormula(SKIN:GetVariable("PAD"))
	BARW = SKIN:ParseFormula(SKIN:GetVariable("BARW"))
	AY = SKIN:ParseFormula(SKIN:GetVariable("AY"))

	local color = SKIN:ReplaceVariables(SKIN:GetVariable("Color", "FFFFFF"))
	colors = {}

	inc = "; auto-generated by GradientWindow.lua\n"

	if color:match("|") == nil then
		color = color:match("([^:]+)")
		local r,g,b,a = parseColor(color)
		colors[1] = { ["color"]=r .. "," .. g .. "," .. b .. "," .. a, ["p"]=0 }
		colors[2] = { ["color"]=r .. "," .. g .. "," .. b .. "," .. a, ["p"]=100 }
	else
		for v in string.gmatch(color, '[^|]+') do
			local v,p = v:match("([^:]+)[%s]*[:]?[%s]*([^%s]*)")
			local r,g,b,a = parseColor(v)

			if p ~= "" then p = SKIN:ParseFormula(p) end

			colors[#colors + 1] = { ["r"]=r, ["g"]=g, ["b"]=b, ["a"]=a, ["color"]=r .. "," .. g .. "," .. b .. "," .. a, ["p"]=p }
		end

		if colors[1]["p"] == "" then colors[1]["p"] = 0 end
		if colors[#colors]["p"] == "" then colors[#colors]["p"] = 100 end
		for i=2,#colors-1,1 do
			if colors[i]["p"] == "" then
				colors[i]["p"] = 100 / (#colors - 1) * (i - 1)
			end
		end

		-- remove extra points outside of boundary
		local i = 1
		while i < #colors do
			if colors[i]["p"] < 0 and colors[i + 1]["p"] <= 0 then
				table.remove(colors, i)
				i = 0
			else
				break
			end
			i = i + 1
		end
		while i > 1 do
			if colors[i]["p"] > 100 and colors[i - 1]["p"] >= 100 then
				table.remove(colors, i)
				i = #colors + 1
			else
				break
			end
			i = i - 1
		end

		-- normalize endpoints
		if colors[1]["p"] < 0 and colors[2]["p"] > 0 then
			local c1 = colors[1]
			local c2 = colors[2]
			local p = -c1["p"]
			p = p / (p + c2["p"])
			colors[1]["p"] = 0
			local r = math.lerp(c1["r"], c2["r"], p)
			local g = math.lerp(c1["g"], c2["g"], p)
			local b = math.lerp(c1["b"], c2["b"], p)
			local a = math.lerp(c1["a"], c2["a"], p)
			c1["color"] = r .. "," .. g .. "," .. b .. "," .. a
		end
		if colors[#colors]["p"] > 100 and colors[#colors-1]["p"] < 0 then
			local c1 = colors[#colors]
			local c2 = colors[#colors-1]
			local p = c1["p"] - 100
			p = p / (p + 100 - c2["p"])
			colors[1]["p"] = 100
			local r = math.lerp(c1["r"], c2["r"], p)
			local g = math.lerp(c1["g"], c2["g"], p)
			local b = math.lerp(c1["b"], c2["b"], p)
			local a = math.lerp(c1["a"], c2["a"], p)
			c1["color"] = r .. "," .. g .. "," .. b .. "," .. a
		end
	end

	for i=1,#colors-1,1 do
		local p0 = colors[i]["p"]
		local p1 = colors[i+1]["p"]
		local col0 = colors[i]["color"]
		local col1 = colors[i+1]["color"]

		anchor(col0, p0, i)

		if i == 1 and p0 ~= 0 then
			gradient(col0, col0, 0, p0)
		end
		gradient(col0, col1, p0, p1)
		if i == #colors-1 and p1 ~= 100 then
			gradient(col1, col1, p1, 100)
		end
	end
	anchor(colors[#colors]["color"], colors[#colors]["p"], #colors)

	writeToFile("GradientWindow.inc", inc)

	if SELF:GetOption("Refreshed", "0") == "0" then
		SKIN:Bang("!WriteKeyValue", SELF:GetName(), "Refreshed", "1")
		SKIN:Bang("!Refresh")
		return
	else
		SKIN:Bang("!WriteKeyValue", SELF:GetName(), "Refreshed", "0")
		SKIN:Bang("!Redraw")
	end

end

function gradient(col0, col1, p0, p1)
	if p0 == p1 then return end
	inc = inc .. buildSection(p0 .. "_" .. p1, "Meter", "Image",
	"MeterStyle", "styleGradient", "SolidColor", col0, "SolidColor2", col1,
	"X", math.floor(p0 / 100 * BARW) + PAD, "W", math.ceil((p1 - p0) / 100 * BARW))
end

function anchor(col, p, i)
	local command = "[!CommandMeasure s \"anchorSelect(" .. i .. ")\"]"
	local command2  = "[!CommandMeasure s \"anchorDelete(" .. i .. ")\"]"
	local x = math.floor(p / 100 * BARW) + PAD - 8

	inc = inc .. buildSection(i .. "a",
	"Meter", "Image", "MeterStyle", "styleAnchor", "X", x,
	"LeftMouseDownAction", command, "RightMouseDownAction", command2)
	x = x + 1
	inc = inc .. buildSection(i .. "c",
	"Meter", "Image", "MeterStyle", "styleAnchorFill | styleCheck", "X", x)
	inc = inc .. buildSection(i .. "f",
	"Meter", "Image", "MeterStyle", "styleAnchorFill", "X", x, "SolidColor", col)
end

function anchorSelect(index)
	local col = colors[index]["color"]
	local p = colors[index]["p"]

	local x = math.floor(p / 100 * BARW) + PAD - 8
	SKIN:Bang("!SetOption", "p", "X", x)
	SKIN:Bang("!SetOption", "p", "Text", p .. "%")
	SKIN:Bang("!SetOption", "mp", "X", x)
	SKIN:Bang("!SetOption", "mp", "DefaultText", p)
	SKIN:Bang("!SetOption", "mp", "Command1", '!CommandMeasure s "anchorPos(\'$UserInput$\', ' .. index .. ')"')
	SKIN:Bang("!ShowMeter", "p")

	local command = "[!CommandMeasure s \"anchorColor('%color%'," .. index .. ")\" \"#*ROOTCONFIG*#\\SettingsWindow\\GradientWindow\"]"
	x = SKIN:GetVariable("CURRENTCONFIGX") + x
	local y = SKIN:GetVariable("CURRENTCONFIGY") + AY + 32
	SKIN:Bang("!WriteKeyValue", "Variables", "Color", col, "#ROOTCONFIGPATH#SettingsWindow\\ColorPopup\\ColorPopup.ini")
	SKIN:Bang("!WriteKeyValue", "Variables", "Callback", command, "#ROOTCONFIGPATH#SettingsWindow\\ColorPopup\\ColorPopup.ini")
	SKIN:Bang("!Refresh", "#ROOTCONFIG#\\SettingsWindow\\ColorPopup")
	SKIN:Bang("!Move", x, y, "#ROOTCONFIG#\\SettingsWindow\\ColorPopup")
	SKIN:Bang("!Show", "#ROOTCONFIG#\\SettingsWindow\\ColorPopup")
end

function anchorColor(col, index)
	colors[index]["color"] = col
	save()
end

function anchorPos(pct, index)
	pct = pct:match("^[%s]*([%d]*)")
	if pct == "" then return end
	pct = tonumber(pct)
	local colorTable = colors[index]
	local p = colorTable["p"]
	colorTable["p"] = pct

	if pct < p then
		for i=1,index-1,1 do
			if pct < colors[i]["p"] then
				table.remove(colors, index)
				table.insert(colors, i, colorTable)
				break
			end
		end
	elseif pct > p then
		for i=#colors,index+1,-1 do
			if pct > colors[i]["p"] then
				table.remove(colors, index)
				table.insert(colors, i, colorTable)
				break
			end
		end
	end

	save()
end

function anchorNew(p)
	for i=1,#colors,1 do
		if p < colors[i]["p"] then
			table.insert(colors, i, { ["color"]="0,0,0,255", ["p"]=p })
			break
		end
	end
	save()
end

function anchorDelete(i)
	if #colors == 1 then return end
	table.remove(colors, i)
	local x = SKIN:GetVariable("CURRENTCONFIGX")
	local y = SKIN:GetVariable("CURRENTCONFIGY")
	SKIN:Bang("!CommandMeasure", "s", "resolve(" .. x .. "," .. y .. ",1)", "#ROOTCONFIG#\\SettingsWindow\\ColorPopup")
	save()
end

function save()
	local col = getGradientString()
	SKIN:Bang("!WriteKeyValue", "Variables", "Color", col)
	SKIN:Bang("!WriteKeyValue", "Variables", "ItemColor", col, "#ROOTCONFIGPATH#Settings.inc")
	SKIN:Bang("!Refresh", "#ROOTCONFIG#")
	SKIN:Bang("!Refresh")
end
