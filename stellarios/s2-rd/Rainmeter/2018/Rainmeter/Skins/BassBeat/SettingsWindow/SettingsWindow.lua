-- @author Malody Hoe / GitHub: undefinist / Twitter: undefinist

function trim(s)
	return (s:gsub("^%s*(.-)%s*$", "%1"))
end

function normalizePath(p)
	while true do
		local i = 0
		p, i = p:gsub("[^%.\\]+\\%.[%.]?\\", "")
		if i == 0 then break end
	end
	return p
end

function math.clamp(value, lower, upper)
	return math.min(math.max(value, lower), upper)
end

function writeToFile(fileName, content)
	local file = io.open(SKIN:MakePathAbsolute(fileName), "w")
	file:write(content)
	file:close()
end



function getOption(meter, option, default)
	local v = meter:GetOption(option)
	if v ~= '' then return v end

	local styles = meter:GetOption("MeterStyle")
	if styles == '' then return default end

	for style in string.gmatch(styles, '[^|]+') do
		if sections[style] ~= nil then
			if sections[style][option] ~= nil then
				return sections[style][option]
			end
		end
	end

	return default
end

function getKeyValue(header, key, default)
	if sections[header] ~= nil then
		if sections[header][key] ~= nil then
			return sections[header][key]
		end
	end
	return default
end

function setVar(variable, value)
	SKIN:Bang("!WriteKeyValue", "Variables", variable, value, variablesFile)
	SKIN:Bang("!SetVariable", variable, value)
end

function findUiMeter(mouseX, mouseY)
	for i,v in ipairs(uiMeters) do
		if v["meter"]:GetOption("Hidden", "0") == "0" and ptInMeter(v["meter"], mouseX, mouseY) then
			return v
		end
	end
	return nil
end

function ptInMeter(meter, x, y)
	local mx = meter:GetX()
	local my = meter:GetY()
	local mw = meter:GetW()
	local mh = meter:GetH()
	return x >= mx and y >= my and x <= mx + mw and y <= my + mh
end

function findMeter(mouseX, mouseY)
	local meter = findUiMeter(mouseX, mouseY)
	if meter ~= nil then return meter,meter["type"] end
	if ptInMeter(window["meter"], mouseX, mouseY) then return window,"Window" end
end



function Initialize()

	SKIN:Bang("!Draggable", 0)
	SKIN:Bang("!ClickThrough", 0)
	SKIN:Bang("!KeepOnScreen", 0)
	SKIN:Bang("!ZPos", 0)

	mouseStartPos = {}
	mouseLastPos = {}
	mouseMove = {}

	configX = SKIN:GetVariable("CURRENTCONFIGX")
	configY = SKIN:GetVariable("CURRENTCONFIGY")
	variablesFile = normalizePath(SKIN:MakePathAbsolute(SELF:GetOption("VariablesFile", SKIN:GetVariable("CURRENTFILE"))))

	SKIN:Bang("!ActivateConfig", "#CURRENTCONFIG#\\GradientWindow")
	SKIN:Bang("!Move", configX, configY + 184, "#CURRENTCONFIG#\\GradientWindow")
	SKIN:Bang("!ZPos", 1, "#CURRENTCONFIG#\\GradientWindow")
	SKIN:Bang("!Hide", "#CURRENTCONFIG#\\GradientWindow")

	SKIN:Bang("!ActivateConfig", "#CURRENTCONFIG#\\ColorPopup")
	SKIN:Bang("!ZPos", 2, "#CURRENTCONFIG#\\ColorPopup")
	SKIN:Bang("!Hide", "#CURRENTCONFIG#\\ColorPopup")

	uiMeters = {}
	window = nil
	initialized = true

	local selfName = SELF:GetName()

	getSections()

	inc = "; auto-generated by SettingsWindow.lua\n"

	parseLayout()
	writeToFile("SettingsWindow.inc", inc)

	if SELF:GetOption("Refreshed", "0") == "0" then
		SKIN:Bang("!WriteKeyValue", SELF:GetName(), "Refreshed", "1")
		SKIN:Bang("!Refresh")
		return
	else
		SKIN:Bang("!WriteKeyValue", SELF:GetName(), "Refreshed", "0")
	end

	for i=1,#uiMeters,1 do
		uiMeters[i]["meter"] = SKIN:GetMeter(uiMeters[i]["name"])
	end
	for i,group in ipairs(groups) do
		SKIN:Bang("!HideMeterGroup", group["name"])
	end
	SKIN:Bang("!ShowMeterGroup", SKIN:GetVariable("CurrentMeterGroup", groups[1]["name"]))
	curGroup = nil

	if SKIN:GetVariable("NewInstalled", "1") == "1" then
		SKIN:Bang("!Move 0 0")
		SKIN:Bang("!WriteKeyValue Variables NewInstalled 0")
		SKIN:Bang("!Refresh")
	end
end

function getSections()
	local curHeader = ""
	sections = {}
	for line in io.lines(SKIN:MakePathAbsolute(SKIN:GetVariable("CURRENTFILE"))) do
		local l = trim(line) -- trim whitespace
		if l:byte() ~= 59 and l ~= "" and l ~= "=" then -- semicolon is 59
			if l:byte() == 91 then -- left sqr bracket is 91 [
				curHeader = l:sub(2,-2)
				sections[curHeader] = {}
			else
				local k,v = l:match("([^%s=]+)=(.*)")
				sections[curHeader][k] = v
			end
		end
	end
end

function parseLayout()
	window = SKIN:GetMeter("Window")
	local pl,pt,pr,pb = 0,0,0,0
	local paddingStr = window:GetOption("Padding")
	if paddingStr ~= "" then
		pl,pt,pr,pb = paddingStr:match("([^,]+),([^,]+),([^,]+),([^,]+)")
	end
	window = { ["meter"]=window, ["type"]="Window", ["pl"]=pl, ["pt"]=pt, ["pr"]=pr, ["pb"]=pb }

	groups = {}
	for line in io.lines(SKIN:MakePathAbsolute("Layout.txt")) do
		local l = trim(line) -- trim whitespace
		local values = {}
		for v in string.gmatch(l, '[^|]+') do
			values[#values + 1] = v
		end
		parseLayoutLine(values)
	end
end

function parseLayoutLine(args)
	if args[1] == "Group" then
		local name = args[2]
		createGroup(name)
		return
	end

	if args[1] == "Range" then
		local var = args[2]
		local params = args[3]
		local label,tooltip = args[4]:match("([^:]+)[:]?(.*)") -- label[:tooltip]
		_line()
		_label(var, label, tooltip)
		_range(var, params)
		_input(var, "Range", params)
	elseif args[1] == "Checkbox" then
		local var = args[2]
		local label,tooltip = args[3]:match("([^:]+)[:]?(.*)")
		_line()
		_label(var, label, tooltip)
		_checkbox(var)
	elseif args[1] == "Select" then
		local var = args[2]
		local options = args[3]
		local label,tooltip = args[4]:match("([^:]+)[:]?(.*)")
		_line()
		_label(var, label, tooltip)
		_select(var, options)
	elseif args[1] == "Color" then
		local var = args[2]
		local label,tooltip = args[3]:match("([^:]+)[:]?(.*)")
		_line()
		_label(var, label, tooltip)
		_color(var)
	elseif args[1] == "Label" then
		local name = args[2]:gsub("%s", "")
		local label,tooltip = args[2]:match("([^:]+)[:]?(.*)")
		_line()
		_label(name, label, tooltip)
	end
end

function createGroup(name)
	groups[#groups + 1] = {}
	curGroupIndex = #groups
	curGroup = groups[#groups]
	curGroup["name"] = name
	curGroup["oX"] = window["pl"]
	curGroup["oY"] = window["pt"]
	drawY = curGroup["oY"]
	drawH = 0
end

function _line()
	drawX = curGroup["oX"]
	drawY = drawY + drawH
end

function _elem(type)
	local style = "style" .. type
	local w = SKIN:ParseFormula(getKeyValue(style, "W", 0))
	local h = SKIN:ParseFormula(getKeyValue(style, "H", 0))
	local x = SKIN:ParseFormula(getKeyValue(style, "X", 0))
	local y = SKIN:ParseFormula(getKeyValue(style, "Y", 0))
	local margin = getKeyValue(style, "Margin", "")

	local ml,mt,mr,mb = 0,0,0,0
	if margin ~= "" then
		ml,mt,mr,mb = margin:match("([^,]+),([^,]+),([^,]+),([^,]+)")
	end

	drawX = drawX + ml
	x = drawX + x
	y = drawY + mt + y
	drawX = drawX + w + mr

	if h + mt + mb > drawH then drawH = h + mt + mb end

	return x,y,w,h
end

function _label(var, label, tooltip)
	local x,y = _elem("Label")
	inc = inc .. buildSection(var .. "_Label",
	"Meter", "String", "Text", label, "MeterStyle", "styleLabel",
	"X", x, "Y", y, "Tip", tooltip)
end

function _range(var, params)
	local x,y,w,h = _elem("Range")
	inc = inc .. buildSection(var .. "_Range",
	"Meter", "Image", "MeterStyle", "styleRange",
	"X", x, "Y", y)

	w = getKeyValue("styleRangeFill", "W", w)
	h = getKeyValue("styleRangeFill", "H", h)
	x = x + getKeyValue("styleRangeFill", "X", 0)
	y = y + getKeyValue("styleRangeFill", "Y", 0)

	local min, max, step = params:match("([^,]+),([^,]+),([^,]+)")
	local formula = "((#" .. var .. "#-" .. min .. ")/(" .. (max - min) .. ")*" .. w .. ")"
	inc = inc .. buildSection(var .. "_RangeFill",
	"Meter", "Image", "MeterStyle", "styleRangeFill",
	"H", h, "W", formula, "X", x, "Y", y)

	uiMeters[#uiMeters + 1] = {}
	m = uiMeters[#uiMeters]
	m["name"] = var .. "_Range"
	m["type"] = "Range"
	m["variable"] = var
	m["min"] = min
	m["max"] = max
	m["step"] = step
end

function _input(var, inputType, params)
	local x,y,w,h = _elem(inputType .. "Input")
	local style = "style" .. inputType .. "Input"
	local name = var .. "_" .. inputType .. "Input"

	if params ~= "" and params ~= nil then
		params = "," .. params:match("[%d%s]+,[%d%s]+")
	end
	local command = "input_" .. inputType .. "('$UserInput$','" .. var .. "'" .. params .. ")"
	command = "[!SetOption mInput DefaultValue #" .. var .. "#][!SetOption mInput X " .. x .. "][!SetOption mInput Y " .. y .. "][!SetOption mInput W " .. w .. "][!SetOption mInput H " .. h .. "][!SetVariable InputCommand \"" .. command .. "\"]"

	inc = inc .. buildSection(name,
	"Meter", "String", "MeterStyle", style,
	"Text", "#" .. var .. "#", "X", x, "Y", y,
	"LeftMouseUpAction", command .. '[!CommandMeasure mInput "ExecuteBatch 1"][!Refresh #ROOTCONFIG#]'
	)

	-- if params ~= "" and params ~= nil then
	-- 	params = "," .. params:match("[%d%s]+,[%d%s]+")
	-- end
	-- local command = "input_" .. inputType .. "('$UserInput$', '" .. var .. "'" .. params .. ")"
	-- inc = inc .. buildSection(name .. "_Measure",
	-- "Measure", "Plugin", "Plugin", "InputText", "UpdateDivider", -1, "DynamicVariables", 1,
	-- "H", h, "W", w, "X", x, "Y", y,
	-- "SolidColor", getKeyValue(style, "SolidColor", "FFFFFF"),
	-- "FontFace", getKeyValue(style, "FontFace", "Calibri"),
	-- "FontSize", getKeyValue(style, "FontSize", 16),
	-- "FontColor", getKeyValue(style, "FontColor", "000000"),
	-- "DefaultValue", "#" .. var .. "#",
	-- "OnDismissAction", '[!ShowMeter "' .. name .. '"][!Update][!Redraw]',
	-- "Command1", '[!CommandMeasure "' .. SELF:GetName() .. '" "' .. command .. '"][!Refresh #ROOTCONFIG#][!Update][!Redraw]'
	-- )
end

function _checkbox(var)
	local x,y,w,h = _elem("Checkbox")
	inc = inc .. buildSection(var .. "_Checkbox",
	"Meter", "Image", "MeterStyle", "styleCheckbox",
	"X", x, "Y", y)

	w = getKeyValue("styleCheckboxFill", "W", w)
	h = getKeyValue("styleCheckboxFill", "H", h)
	x = x + getKeyValue("styleCheckboxFill", "X", 0)
	y = y + getKeyValue("styleCheckboxFill", "Y", 0)

	local hidden = "(#" .. var .. "#)"

	inc = inc .. buildSection(var .. "_CheckboxFill",
	"Meter", "Image", "MeterStyle", "styleCheckboxFill",
	"H", "(" .. h .. " * " .. hidden .. ")", "W", w,
	"X", x, "Y", y)

	uiMeters[#uiMeters + 1] = {}
	m = uiMeters[#uiMeters]
	m["name"] = var .. "_Checkbox"
	m["type"] = "Checkbox"
	m["variable"] = var
end

function _select(var, options)
	local x,y,w,h = _elem("Select")
	local text = "#" .. var .. "#"
	local curVal = SKIN:GetVariable(var)

	uiMeters[#uiMeters + 1] = {}
	m = uiMeters[#uiMeters]
	m["name"] = var .. "_Select"
	m["type"] = "Select"
	m["variable"] = var
	m["options"] = {}
	for v in string.gmatch(options, '[^,]+') do
		local name,value = v:match("([^:]+)[:]?(.*)")
		if value == "" then value = name end
		m["options"][#m["options"] + 1] = { ["name"]=name, ["value"]=value }

		if value == curVal then text = name end
	end

	if #m["options"] == 1 then
		if m["options"][1]["name"]:byte() == 36 then -- char 36 is $
			for i,v in ipairs(f[m["options"][1]["name"]]()) do
				if v["value"] == curVal then text = v["name"] end
			end
		end
	end

	inc = inc .. buildSection(var .. "_Select",
	"Meter", "String", "MeterStyle", "styleSelect", "Text", text,
	"X", x, "Y", y, "H", h)
end

function _color(var)
	local x,y,w,h = _elem("Checkbox")
	inc = inc .. buildSection(var .. "_Color",
	"Meter", "Image", "MeterStyle", "styleCheckbox",
	"X", x, "Y", y)

	w = getKeyValue("styleCheckboxFill", "W", w)
	h = getKeyValue("styleCheckboxFill", "H", h)
	x = x + getKeyValue("styleCheckboxFill", "X", 0)
	y = y + getKeyValue("styleCheckboxFill", "Y", 0)

	local color = "#" .. var .. "#"

	inc = inc .. buildSection(var .. "_ColorFill",
	"Meter", "Image", "MeterStyle", "styleCheckboxFill",
	"H", h, "W", w, "X", x, "Y", y, "SolidColor", color)

	uiMeters[#uiMeters + 1] = {}
	m = uiMeters[#uiMeters]
	m["name"] = var .. "_Color"
	m["type"] = "Color"
	m["variable"] = var
end

function buildSection(header, ...)
	local str = "[" .. header .. "]"
	local n = select("#", ...)
	n = n - (n % 2)
	if n == 0 then return str end

	str = str .. "\n"

	for i=1,n,2 do
		local k = select(i, ...)
		local v = select(i + 1, ...)
		str = str .. k .. "=" .. v .. "\n"
	end

	if curGroup ~= nil then
		str = str .. "Group=" .. curGroup["name"] .. "\n"
	end

	return str
end



function input_Text(userInput, variable)
	setVar(variable, userInput)
end

function inputFloat(userInput, variable)
	local num = SKIN:ParseFormula(userInput)
	if num == nil then return end
	setVar(variable, num)
end

function input_Range(userInput, variable, min, max)
	local num = SKIN:ParseFormula(userInput)
	if num == nil then return end
	num = math.clamp(math.floor(num), min, max)
	setVar(variable, num)
end

function input_Color(userInput, variable)
	local value = userInput:match("^[^,]+,[^,]+,[^,]+[,]?[^,]*[,]-")
	if value == nil then
		value = userInput:match("^%x%x%x%x%x%x%x%x$") or userInput:match("^%x%x%x%x%x%x$")
	end
	if value ~= nil then
		setVar(variable, value)
	end
end

function mouse_action(x, y, a)
	SKIN:Bang("!CommandMeasure", "s", "resolve(" .. x .. "," .. y .. "," .. a .. ")", "#CURRENTCONFIG#\\ColorPopup")
	resolve(x, y, a)
	SKIN:Bang("!Update")
	SKIN:Bang("!Redraw")
end

function resolve(mouseX, mouseY, mouseAction)

	if SKIN:GetVariable("Focus", "0") == "0" then
		if popup ~= nil then
			SKIN:Bang("!DeactivateConfig", popup)
			popup = nil
		end
		return
	end

	mouseX = SKIN:ParseFormula(mouseX)
	mouseY = SKIN:ParseFormula(mouseY)

	if mouseAction == 1 then
		mouseStartPos["x"] = mouseX
		mouseStartPos["y"] = mouseY
		mouseLastPos["x"] = mouseX
		mouseLastPos["y"] = mouseY
	elseif mouseAction == 2 then
		mouseMove["x"] = mouseX - mouseLastPos["x"]
		mouseMove["y"] = mouseY - mouseLastPos["y"]
		mouseLastPos["x"] = mouseX
		mouseLastPos["y"] = mouseY
	end

	mouseX = mouseX - configX
	mouseY = mouseY - configY

	local variable = nil
	local value = nil

	local meter,type = findMeter(mouseX, mouseY)

	if mouseAction == 1 then
		if meter == nil then
			if popup ~= nil then
				SKIN:Bang("!DeactivateConfig", popup)
				popup = nil
			end
			return
		end
		focus = meter
		if popup ~= nil then
			SKIN:Bang("!DeactivateConfig", popup)
			popup = nil
		end
	elseif mouseAction == 2 then
		if focus == nil then return end
		meter = focus
		type = meter["type"]
	else
		if focus ~= nil and focus ~= window then SKIN:Bang("!Refresh", "#ROOTCONFIG#") end
		focus = nil
		return
	end

	if type == "Range" then
		mouseX = mouseX - meter["meter"]:GetX()
		mouseY = mouseY - meter["meter"]:GetY()
		local rangeMin = meter["min"]
		local rangeMax = meter["max"]
		local rangeStep = meter["step"]
		local rw = meter["meter"]:GetW()
		local a = math.clamp(mouseX / rw, 0, 1)
		local range = rangeMax - rangeMin
		local numOfSteps = math.floor(range / rangeStep)

		variable = meter["variable"]
		value = math.floor(a * numOfSteps + 0.5) * rangeStep + rangeMin

	elseif type == "Checkbox" then
		if mouseAction ~= 1 then return end
		variable = meter["variable"]
		value = 1 - SKIN:ParseFormula(SKIN:GetVariable(variable))

	elseif type == "Select" then
		if mouseAction ~= 1 then return end

		selectPopup(meter["variable"], meter["options"])

		local x = meter["meter"]:GetX() + configX
		local y = meter["meter"]:GetY() + meter["meter"]:GetH() + configY
		SKIN:Bang("!ActivateConfig", "#CURRENTCONFIG#\\SelectPopup")
		SKIN:Bang("!Move", x, y, "#CURRENTCONFIG#\\SelectPopup")
		SKIN:Bang("!ZPos", 2, "#CURRENTCONFIG#\\SelectPopup")
		popup = "#CURRENTCONFIG#\\SelectPopup"
		return

	elseif type == "Color" then
		if mouseAction ~= 1 then return end

		local x = meter["meter"]:GetX() + configX
		local y = meter["meter"]:GetY() + meter["meter"]:GetH() + configY
		local col = SKIN:GetVariable(meter["variable"])
		local command = "[!WriteKeyValue Variables " .. meter["variable"] .. " #Color# \"" .. variablesFile .. "\"][!SetVariable " .. meter["variable"] .. " #Color# \"#ROOTCONFIG#\\SettingsWindow\"][!Refresh #ROOTCONFIG#]"
		SKIN:Bang("!WriteKeyValue", "Variables", "Color", col, "ColorPopup\\ColorPopup.ini")
		SKIN:Bang("!WriteKeyValue", "Variables", "Callback", command, "ColorPopup\\ColorPopup.ini")
		SKIN:Bang("!Refresh", "#CURRENTCONFIG#\\ColorPopup")
		SKIN:Bang("!Move", x, y, "#CURRENTCONFIG#\\ColorPopup")
		SKIN:Bang("!Show", "#CURRENTCONFIG#\\ColorPopup")
		return

	elseif type == "Window" and mouseAction == 2 then
		configX = configX + mouseMove["x"]
		configY = configY + mouseMove["y"]
		SKIN:Bang("!Move", configX, configY)
		SKIN:Bang("!Move", configX, configY + 184, "#CURRENTCONFIG#\\GradientWindow")
		return
	end

	setVar(variable, value)

end

function selectPopup(var, options)
	if options == nil then return end

	print(options[1]["name"])

	if #options == 1 then
		if options[1]["name"]:byte() == 36 then -- char 36 is $
			selectPopup(var, f[options[1]["name"]]())
			return
		end
	end

	local _inc = ""
	for i,o in ipairs(options) do
		local name = o["name"]
		local v = o["value"]
		_inc = _inc .. buildSection(i - 1,
		"Meter", "String", "MeterStyle", "s", "Text", name,
		"LeftMouseDownAction",
		"[!SetVariable %var% %v% \"#ROOTCONFIG#\\SettingsWindow\"][!WriteKeyValue Variables %var% %v% \"" .. variablesFile .. "\"][!SetOption %var%_Select Text %name% \"#ROOTCONFIG#\\SettingsWindow\"][!Refresh \"#ROOTCONFIG#\\SettingsWindow\"][!DeactivateConfig]"
		):gsub("%%var%%", var):gsub("%%v%%", '"' .. v .. '"'):gsub("%%name%%", '"' .. name .. '"')
	end
	writeToFile("SelectPopup\\SelectPopup.inc", _inc)
end

function tooltip(meter)
	local tip = SKIN:GetMeter(meter):GetOption("Tip")
	if tip ~= "" then
		SKIN:Bang("!SetOption", "Footer", "Text", tip)
	end
end

f = {
	["$audioDevices"] = function()
		local table = { { ["value"]="", ["name"]="Default" } }
		for l in SKIN:GetMeasure("mAudioDevices"):GetStringValue():gmatch("[^\n]+") do
			local id,name = l:match("({[^:]+}): (.+)")
			if id ~= nil then
				table[#table + 1] = { ["value"]=id, ["name"]=name }
			end
		end
		return table
	end
}
